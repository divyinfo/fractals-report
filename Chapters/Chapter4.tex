% Chapter Template

\chapter{Implementation} % Main chapter title

\label{Chapter4} % Change X to a consecutive number; for referencing this chapter elsewhere, use \ref{ChapterX}

In this chapter, the overall structure of the project, how the files are arranged and the functionalities of each components, will be described in details.

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Files And Folders}

The folder names and file names are mostly self-explanatory or conventional in this project. They'll be described briefly in this section.

\begin{figure}[th]
\centering
\includegraphics{Figures/Chapter4/filestructure.png}
\decoRule
\caption[File Structure]{A glimpse of files and folders.}
\label{fig:filestructure}
\end{figure}

\subsection{Folders}

\paragraph{Folder \texttt{./.vscode}}

The configured Visual Studio Code workspace settings file. This file is included and stored inside the workspace and only apply when the workspace is opened which overrides Visual Studio Code's default user settings. The author tweaked this file to make some parts of VS Code's editor, user interface, and functional behavior more fitting to review or to base future work upon this project\footnote{ To learn more about this file, see \url{https://code.visualstudio.com/docs/getstarted/settings}.}. 

VS Code provides two different scopes for settings:

\begin{itemize}
  \item User Settings - Settings that apply globally to any instance of VS Code you open.
  \item Workspace Settings - Settings stored inside your workspace and only apply when the workspace is opened.
\end{itemize}

Workspace settings override user settings\cite{bib:ms:vscode}.

\paragraph{Folder \texttt{./js}}

All the third-party open source \gls{js} dependencies are stored in this folder. Sometimes third-party open source projects include a bundle of \acrfull{js} and \gls{css} files, here only the pure \gls{js} projects' files are included.

\paragraph{Folder \texttt{./css}}

The \gls{css} files of the projects are included. Firstly there is a \\\texttt{./css/common.css} file, which sets the overall styles of the project, basically whatever the users can see at the very first glance when they open this project. Then there are several other \gls{css} files, each sets a specific portion of the styles in this project. These files include:

\begin{itemize}
\item \gls{css} File \texttt{./css/dock.css} sets the iOS-Dock look-like styles, making the focused item larger with larger margins and adjacent items smaller and smaller margins with their corresponding nearby items.
\item \gls{css} File \texttt{./css/minibar.css} sets the customed scrollbar styles that's being added upon the default styles of the dependency \emph{MiniBar} which is used to create custom scrollbars.
\item \gls{css} File \texttt{./css/stacked.css} sets the styles of the stacked cards effect.
\item \gls{css} File \texttt{./css/tabs.css} sets the related styles of the tabs effect.
\end{itemize}

Note that most of the effects require not only the \gls{css} stylings but also \gls{js} actions in order to work.

\paragraph{Folder \texttt{./fa}}

Assets of the dependency \emph{Font Awesome}, including all resources of the open source part. This dependency is used for the fonts of the icons in this project.

\paragraph{Folder \texttt{./bs}}

Assets of the open source project \emph{Bootstrap} by \emph{Twitter}. This dependency is used for the stylings of the web elements inside the control panel, such as input boxes, dropdown menus and font styles in control panel. It also comes with some nice utilities for general web elements style setting.

\paragraph{Folder \texttt{./node\_modules}}

Packages pulled from the \gls{js} dependency management tool \emph{npm}\footnote{ Build amazing things --- Essential JavaScript development tools that help you go to market faster and build powerful applications using modern open source code\cite{bib:npm:npm}. Too know more about \emph{npm}, see \url{https://www.npmjs.com/}.} are stored in this folder. The required dependency here is the package \texttt{minibarjs} under this folder -- in folder \texttt{./node\_modules/minibarjs}. Conventionally this folder shouldn't be included or committed to the version control system\footnote{ This is actually also what this project is following. }, because all the packages info are recorded in the file \texttt{package.json} and \texttt{package-lock.json} and if any dependencies are missing, running the \emph{npm} command \texttt{npm install} should be able to pull all necessary dependencies into this folder, however, considering this project sometimes can be run in an environment without internet connection, this folder is included in the final static zipped package.

\paragraph{Folder \texttt{./exp}}

Some trivial \emph{Python}, \gls{js} and \gls{html} codes left from the prototypes of implementation at the beginning of this project. Some of them are using different algorithms and different scripts trying to achieve similar results to this project. They are not in use anymore and only kept for future references.

\subsection{Top Level Files}

\paragraph{File \texttt{index.html}}

This entry \gls{html} file of this project. When a server is being run on the local machine, this is the first file getting executed. When a different implementation of the back end using techniques other than a web worker, for example a \texttt{WebSocket}, is developed and being adapted to this project, double-clicking on this file should also start this project.

\paragraph{File \texttt{index.js}}

The main \gls{js} script file of the project. This file gets included at the very end of the \gls{html} file \texttt{index.html}.

\paragraph{File \texttt{naive-worker.js}}

The back end calculation \gls{js} script. The only job of this script is to receive information of the image the front end is asking for, and post the result message back to the front end. This piece of scripts not only post the complete results back, but also slices of results when the calculation takes longer than a certain amount of time and let the front end decide what to do with the partial results\footnote{ In this project, what the front end will do after receiving partial results is that it will still render the slices of images onto the canvas and high light the painted partial image with green borders. }.

\paragraph{File \texttt{package.json}}

A description file of the \gls{js} package management tool \emph{npm}. This file can have many descriptions about what \emph{npm} should do for this workspace\footnote{ For for detailed information, see \url{https://docs.npmjs.com/files/package.json}.} but here it most importantly specifies which packages to pull from the global repository, in the \gls{json} field \texttt{'dependencies'}. Dependencies are specified in a simple object that maps a package name to a version range. The version range is a string which has one or more space-separated descriptors. Dependencies can also be identified with a tarball or git URL\cite{bib:npm:packagejson}.

\paragraph{File \texttt{package-lock.json}}

A generated file from \emph{npm} package manager which locks the version of the dependencies of this specific workspace. Take the current project as an example, in file \texttt{package.json} there is this part in the \gls{json} body:

\begin{verbatim}
  {
    ..
    "dependencies": {
      ..
      "minibarjs": "^0.4.0",
      ..
    },
    ..
  }
\end{verbatim}

This piece of code only specified that the version of the package \texttt{minibarjs} that we require will match all \texttt{0.x.x} releases including \texttt{0.5.x}, but will hold off on \texttt{1.x.x}. This file \texttt{package-lock.json} will ``lock'' the version inside current workspace to a specific version with a hashed fingerprint of the files, in the current project with a version number of \texttt{0.4.0} and a hash fingerprint \path{sha512-iCUE/YVWn+0ht+NV2fLBS8bAVxED/9l6A5i1qJ20csCrc0tXHamgpWCo7uL+23HQ0UyFPvpw1izw2l3vzVKkXg==}.

\paragraph{File \texttt{README.md}}

A brief introduction file for the global version control system \emph{GitHub}. Trivial.

\paragraph{File \texttt{.gitignore}}

Version control settings file, telling which files should not be committed to \emph{Git} system. Not relavant to the project but the version control during the development phase of this project. Trivial.

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Start the Project}\label{chap4:starttheproject}

Although this project is a pure web project, it cannot be started by simply double-clicking on the entry file \texttt{index.html}, because modern browsers usually don't not allow local scripts to directly start \emph{Web Worker}s\footnote{ Web Workers are a simple means for web content to run scripts in background threads.\cite{bib:moz:webworker}} for security concerns. However, \emph{Web Worker} is being used in this project as simple means for doing heavy calculations in background threads without interfering with the \gls{ui}, therefore, in order to start the project, a simple \gls{http} server must be up and running on the local machine.

It is also worth mentioning that this project should be running with Google Chrome browser as it supports most of the advanced visual effects and modern web technology syntax, known as \emph{HTML5}\footnote{ See \url{https://developer.mozilla.org/en-US/docs/Web/Guide/HTML/HTML5} for more detailed information.}. The recommended version of Google Chrome is \path{76.0.x}.

To start and keep a \gls{http} server running, the simplest and recommended way would be to use \emph{Python}'s \texttt{http.server}. To do that\cite{bib:moz:simplehttp}:

\paragraph{Install Python} If you are using \emph{Linux} or \emph{macOS}, it should be available on the system already. If you are a \emph{Windows} user, \emph{Python} installer can be downloaded from the \emph{Python} homepage and the instructions can be followed to install it:

\begin{itemize}
  \item Go to \url{python.org}
  \item Under the \emph{Download} section, click the link for \texttt{Python 3.xxx}.
  \item At the bottom of the page, choose the \emph{Windows x86 executable installer} and download it.
  \item When it has downloaded, run it.
  \item On the first installer page, make sure you check the \emph{``Add Python 3.xxx to PATH''} checkbox.
  \item Click \emph{Install}, then click \emph{Close} when the installation has finished.
\end{itemize}

\paragraph{Verification}

Open a \emph{Command Prompt} (Windows) / \emph{Terminal} (macOS / Linux). To check \emph{Python} is installed, enter the following command:

\begin{verbatim}
  python -V
\end{verbatim}

\paragraph{Navigation}

The above command should return a version number. If this is OK, navigate to the directory that the files of this project is inside, using the \texttt{cd} command.

\begin{verbatim}
  # include the directory name to enter it, for example
  cd Desktop/fractals
\end{verbatim}

\paragraph{Start the Server}

Enter the command to start up the server in that directory:

\begin{verbatim}
  # If Python version returned above is 3.X:
  python -m http.server
  
  # Or simply:
  py -m http.server

  # If Python version returned above is 3.X
  # and on non-Windows machines:
  python3 -m http.server

  # If Python version returned above is 2.X,
  # or if on macOS using the default Python
  # installed:
  python -m SimpleHTTPServer
\end{verbatim}

By default, the above actions will run the contents of the directory where the files of this project are located on a local web server, on port $8000$. In order to view this project now, simply go to this server by going to the \gls{url} \texttt{localhost:8000} in your web browser, to be specific and recommended in Google Chrome. Here the project entry \texttt{index.html} will be run by default and users can see directly the result.

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Front End}

Since this project is a pure web project, the front end occupies a large portion of the codes.

\subsection{HTML Entry \texttt{index.html}}

The entry of the project is where this program gets started, in similar concept of the \texttt{main()} function in \texttt{C} or the \texttt{public static void main(String[] args)} function in \texttt{Java}. The entry point is a \gls{html} file and as expected named \texttt{index.html}. It introduces the front end structure of the project in raw.

First part of the \gls{html} file is the \texttt{<head>} part. In this part, the character set of this web page is defined as \emph{UTF-8}, the size of the entire \gls{html} document as fullscreen size, scaling not allowed and not shrinking to display its content.

\begin{verbatim}
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,
      initial-scale=1, shrink-to-fit=no">
\end{verbatim}

And then all the needed \gls{css} files are included to end the \texttt{<head>} part. Besides the \gls{css} files which will be described in \gmref{chap4:frontend-css}, the necessary \gls{css} files from third-party open source vendors are also included, including \emph{Bootstrap}'s \gls{css} part, \emph{FontAwesome} and \emph{MiniBar} \gls{css} assets.

The \texttt{<body>} part is the essential part of the \gls{html} entry, which describes the structure of what users can ``actually see''. It begins first with three \texttt{<div>} tags for the most important three parts of this project, the container for main background canvases, the container for mini-maps, and the container for the control panel floating on the top right corner of the \gls{ui} screen. The positioning, sizes and container behaviours of these \texttt{<div>}s are defined in the \gls{css} files which are already included. Before users set any effects up, these properties mostly come from the file \texttt{./css/common.css}.

\begin{figure}[th]
\centering
\includegraphics[width=\textwidth,keepaspectratio]{Figures/Chapter4/rootdom.png}
\decoRule
\caption[DOM Body Structure]{\gls{dom} structure in \texttt{<body>} tag.}
\label{fig:rootdom}
\end{figure}

After the visual \texttt{<div>} part, several \texttt{<script>} tags come after it to include what's necessary for the essential coding part. Here firstly are the dependencies of the project, including \emph{jQuery}, \emph{Bootstrap}'s \gls{js} part, and \emph{MiniBar}'s \gls{js} part. And then at the very end the main \gls{js} file \texttt{index.js} is included and all the core programs of this project goes in there.

Worth noting that conventionally all \gls{js} files should be included at the very end of the page as what we are doing now, unless the \gls{js} file is needed before the render phase of the web page. This way if the \gls{js} file is a little bit bigger than usual, the loading of the \gls{js} files won't affect the rendering process of the \gls{dom} documents.


\subsection{Main JavaScript \texttt{index.js}}

The main \gls{js} file \texttt{index.js} is where the core codes are. In this file there is firstly the definition of required classes from bottom level to the top, then the instantiation of them and putting the front end \gls{html} elements into action to display the overall results.

There in total four classes defined.

\subsubsection{Class \texttt{MandelWorker}}

The class \texttt{MandelWorker} is in charge of sending a message to the back end and when a result is sent back, handle it by executing a preset function(or say callback). This class is the red and green arrows shown in \gmref{fig:fpcpair}.

When instantiated, an instance of a native \emph{Web Worker} will also be created as a private property of this class. \texttt{MandelWorker} instantiates the \emph{Web Worker} by the script \texttt{naive\-worker.js}, which means that the script \texttt{naive\-worker.js} will be the core of the worker and this worker will be doing whatever in that script when it is asked to\footnote{ See \url{https://developer.mozilla.org/en-US/docs/Web/API/Web_Workers_API/Using_web_workers\#Spawning_a_dedicated_worker} for more detailed information of the process of instantiating a \emph{Web Worker}.}.

\textbf{Function \texttt{work(params...)}}

The function \texttt{work(params...)} is the interface between \texttt{MandelWorker} and the outside invoker. To get an image from the source, one must invoke this function with the needed parameters as follows:

\begin{itemize}
  \item \texttt{magnif} The magnification level of the result image to be expected from the \emph{Web Worker}.
  \item \texttt{centerX} The \texttt{x} component of the center coordinates on the mathmatical plane of the result image to be expected from the worker.
  \item \texttt{centerY} The \texttt{y} component of this coordinates.
  \item \texttt{width} The width in pixels of the result image.
  \item \texttt{height} The height in pixels of the result image.
  \item \texttt{callback} The function to execute when a result message is received.
  \item \texttt{callbackThis} The ``this'' context where the \texttt{callback} function should be executed under.
\end{itemize}

Here what's worth mentioning is the parameter \texttt{magnif}. The magnification level is a number representing the number of pixels that together has a length of $1$ on the mathmatical axis. As shown in \gmref{fig:magnif} is an image with the magnification level of $2$, since $2$ pixels have the length of $1$ on the mathmatical axis.

\begin{figure}[th]
\centering
\includegraphics[keepaspectratio]{Figures/Chapter4/magnif.png}
\decoRule
\caption[Magnification Level]{Magnification level in aspect of mathmatical axis.}
\label{fig:magnif}
\end{figure}

Once this function is invoked, \texttt{MandelWorker} will tell its own \emph{Web Worker} to start working on datasets fetching\footnote{ In the context of the current project, is actually image generation. }, and if any sorts of results come through that worker, hit the \texttt{workerResponse(e)} function of the current \texttt{MandelWorker}.

\textbf{Function \texttt{workerResponse(e)}}

The function \texttt{workerResponse(e)} will be called when a response from the \emph{Web Worker} is sent back. It basically does one thing: checking if the parameters of \texttt{callback} and \texttt{callbackThis} were set when function \texttt{work(params...)} got invoked in the first place. If they were set to any function, call it under the conext of the parameter \texttt{callbackThis}.

\textbf{Function \texttt{destroy()}}

The function \texttt{destroy()} as the name implies is the method to destroy and release the resources for current \texttt{MandelWorker}. It terminates the \emph{Web Worker}, sets the response method to \texttt{null} so no responses will be dealt furthermore and sets all other references to \texttt{null} as well so the internal \gls{js} engine can garbage collect\footnote{ In computer science, garbage collection (GC) is a form of automatic memory management. The garbage collector, or just collector, attempts to reclaim garbage, or memory occupied by objects that are no longer in use by the program\cite{wiki:gc}.} all these instance to avoid memory leakage when the calculation gets heavy.

\subsubsection{Class \texttt{MapVisualPair}}

An abstract concept of pairing a minimap\footnote{ Same concept in current project as an \emph{overview}. } with an active focus region with higher resolution, as \gmref{fig:mapvisualpair} is an example of what they actually are respectively. This class is realizing the model of a pair of \gls{fpc} shown in \gmref{fig:fpcpair}.

\begin{figure}[th]
\centering
\includegraphics[width=\textwidth,keepaspectratio]{Figures/Chapter4/mapvisualpair.png}
\decoRule
\caption[Map Visual Pair]{Map area image and visual area(current focus region) image.}
\label{fig:mapvisualpair}
\end{figure}

The minimap representing a relatively ``larger'' area in the dataset and the visual area, which represents the active observing region, actually have both same resolution so they can both be displayed on a \gls{fhd} screen. Although the visual area seems ``smaller'' in comparison with the \gls{map} area, since it's an active region that is being observed by the user, the size of this visual area only represents its dimensions on the mathmatical plane and not smaller pixels-wise.

The \gls{map} image, however, will normally be shrunk and put on the left side of the screen, till the user hovers over a specific \gls{map} that will trigger the preview process of this program so he can have a glance of this image in a \gls{fhd} way.

The reason to pair up a visual area with a \gls{map} area is that whenever the user wants to browse around the dataset, the focusing coordinates on the visual area should also reflect back to the \gls{map} area, and the rectangle representing the current observing area should also get updated automatically. When there are more hierarchies of \glspl{map} present, this pairing mechanism becomes extremely helpful because the changes on the active region will flow all the way up to all levels of \glspl{map} necessary. Here \gmref{fig:mvp-pairflow} is a simple illustration of it.

\begin{figure}[th]
\centering
\includegraphics[width=\textwidth,keepaspectratio]{Figures/Chapter4/mvp-pairflow.png}
% \includegraphics{Figures/Chapter4/mvp-pairflow.png}
\decoRule
\caption[Pairing Multiple Levels of \glspl{map}]{When multiple hierarchies of \glspl{map} present, visual area changes, all \glspl{map} changes.}
\label{fig:mvp-pairflow}
\end{figure}

\textbf{Function} \verb|init(mapCanvas, previewCanvas, visCanvas = null)|

This function will initialize the current \texttt{MapVisualPair}, bounding a \texttt{mapCanvas}, a \texttt{previewCanvas} and a \texttt{visCanvas} all of type \texttt{<canvas>} element to this class. When internally a drawing action should be performed, related images will be drawn on corresponding canvas.

The canvas \texttt{mapCanvas} will be used to draw the shrunk version of the \gls{map} image. \texttt{previewCanvas} will be used to draw the normal(\gls{fhd}) version of the \gls{map} image. And \texttt{visCanvas} will be used to draw the visual area image in \gls{fhd} if set.

After bounding the canvases, this function will also check if any event handlers are bound to the events \texttt{mouseover} and \texttt{mouseout} to the \texttt{mapCanvas} element, and record corresponding info to the element to avoid attemps to rebound event handlers to the same \texttt{<canvas>} element. In this way, only one event handler for \texttt{mouseover} and \texttt{mouseout} will be triggered when the user hovers their mouse on the \texttt{<canvas>} and when the user put their cursor out of the element.

The handlers this function is going to bound to the \texttt{mapCanvas} element are going to first add \gls{css} class \texttt{.nearby} to adjacent siblings of this canvas, and check if any additional callbacks this class should call. The callbacks, if any, which are set in the private properties \texttt{mouseOverCallback} and \texttt{mouseOutCallback}, will be called under set context \texttt{mouseOverCallbackThis} and \texttt{mouseOutCallbackThis} when user performs corresponding actions. As mentioned before, they will also be called only once because the bounding information is recorded. In the project, these callbacks and the contexts of them are set by a manager class \gmref{chap4:effectmanager}.

\textbf{Function} \verb|destroy()|

This function as the name implies releases all in-use resources, including \texttt{Worker}s, unbinding bound event handlers, clearing references to the canvases and their 2d contexts.

\textbf{Function} \verb|drawMapHoverArea(offsetRealX = 0, offsetRealY = 0)|

When the class is told to draw images on corresponding canvas elements, it will not automatically draw the purple rectangle indicating the current observing visual area, since the cached image data does not include this rectangle --- it doesn't belong to the extreme resolution dataset itself, therefore, this function exists to draw this current focus area using a purple rectangle to indicate it, drawing this rectangle on the \texttt{mapCanvas} whenever invoked. Note that whenever the image from the calculation side is fetched, without invoking this function, no current obeserving area rectangle will be shown, since the newly fetched image data will cover the old one also the old drawn rectangle.

The parameters \texttt{offsetRealX} and \texttt{offsetRealY} can also be set, as the purple rectangle to be drawn will then have an offset of (\texttt{offsetRealX}, \texttt{offsetRealY}) with respect to the center of the current observing area on the mathmatical complex plane.

\textbf{Function} \verb|drawPreviewHoverArea(offsetRealX = 0, offsetRealY = 0)|

Like the function \texttt{drawMapHoverArea}, this function will also draw a rectangle representing the current observing visual area, but on another canvas \texttt{previewCanvas}. The reason to separate these two functions is that the canvas \texttt{previewCanvas} isn't always visible and if these two functions are combined, it'll draw unintended purple rectangles on wrong canvases.

\textbf{Function} \verb|moveTo(x = null, y = null)|

This function is used to move the current \texttt{MapVisualPair} around. The parameters of coordinates are on the mathmatical complex plane, i.e. with respect to the entire datasets.

Note that these two parameters can be omitted and when omitted, the current \texttt{MapVisualPair} will simply send a ping to the calculation side and grab new image data for current observing coordinates, like a ``refresh'' action.

\textbf{Properties} \texttt{visMagnif} and \texttt{mapMagnif}

The magnification for the pair of these two canvases. See \gmref{fig:magnif} for the explanation of magnification level.

\textbf{Properties} \texttt{visCenterX} and \texttt{visCenterY}

The coordinates of the center point of the current observing visual area, with respect to the mathmatical complex plane.

\textbf{Properties} \texttt{visCanvasWidth} and \texttt{visCanvasHeight}

The width and height in \textbf{pixels} of the image data of the whole visual area. In \gmref{fig:mapvisualpair}, they're the dimensions of the whole visual area image. These properties have to exist because the dimensions of this area cannot always be fetched from the \texttt{visCanvas} property, as it is an optional parameter during the \texttt{init(params..)} phase and sometimes is absent.

\textbf{Properties} \texttt{visImgOffsetX} and \texttt{visImgOffsetY}

These two properties are set for the dragging actions that are realized in \gmref{chap4:minimapmanager}. They represents the current dragging offset with respect to the top left corner of the \texttt{visCanvas}. The reference point being top left corner not the center point is because in web canvas drawing system, the (0, 0) point is the top left corner, unlike in mathmatical complex plane it being the center.

\textbf{Properties} \texttt{mapCenterX} and \texttt{mapCenterY}

Like the properties \texttt{visCenterX} and \texttt{visCenterY}, these two properties represents the coordinates of the center point of the current \gls{map} area, with respect to the mathmatical complex plane. In \gmref{fig:mapvisualpair}, they're the center coordinates of the \gls{map} image.

\subsubsection{Class \texttt{MinimapManager}}\label{chap4:minimapmanager}

The manager class of all the minimaps, controlling all their behaviours on the top level. This class is described in \gmref{fig:fpcmanager}, the manager of all the \gls{fpc} models, plus a \gls{fhd} visual area.

\textbf{Inits}

\textbf{Function} \path{initMaps(visCanvas, previewCanvas, mapsContainer, visualContain er, hoverX = 0, hoverY = 0)}

This function initializes the states of all the \texttt{MapVisualPair}s that should be displayed, as well as initializing its own requird properties.

The properties \texttt{visCanvas} and \texttt{previewCanvas} are the canvases bound to this manager. \texttt{visCanvas} is the canvas for the main visual area and the details image is rendered on this canvas. \texttt{previewCanvas} is the canvas that's initially hidden, but will be shown when the \texttt{EffectManager} described in \gmref{chap4:effectmanager} instructs, designed for the presentation of the preview images. These two canvases have exactly the same dimensions, covering the entire \gls{ui} viewport, and on the most bottom layer of the page hence being laid over by the \glspl{map} and control panels. \texttt{previewCanvas} in turn lays over \texttt{visCanvas} since when a preview instruction is issued, it has to be displayed over the original visual area.

The property \texttt{mapsContainer} is the container holding all the canvases for the display of \glspl{map}. It's bound to this manager during this initialization phase. During this phase, step one, basic \gls{dom} structure of one \gls{map}, consisting of one \texttt{<cavans>} element and one \texttt{<span>} element for the purpose of showing the \texttt{magnif} number, will be created and appended to this container. The center coordinates of the \gls{map} will be from the parameters \texttt{hoverX} and \texttt{hoverY}, and \texttt{0} if not designated. The \texttt{magnif} level of the first \gls{map} comes from the variable \texttt{mapMagnif} in the global scope of \texttt{index.js}\footnote{ Technically not the global scope of entire \texttt{index.js} file per se, but the ``global scope'' of entire anonymous function that envelops all the codes.}. Based on the \texttt{magnif} of the first \gls{map} and the \texttt{visMagnif} variable defined in global scope, the initial dimensions of the focus area projected on the \gls{map} can be calculated.

With the dimensions of the first \gls{map}, this manager then decides whether additional \glspl{map} are required, based on the results of whether this projected area on \gls{map} is too small. If this area is too small, additional \gls{dom} structure consisting of one \texttt{<canvas>} and one \texttt{<span>} will be created and appended to the container. The criteria of whether this area is too small is defined by the private property \texttt{this.minStrokeW}\footnote{ In pixels.} of this manager. After the new \gls{dom} is created, we then will have two canvases. The first one will be the \gls{map} canvas and the one created after the calculation of the projection area will be the ``visual'' area. These two areas will then be paired up, forming an object of \texttt{MapVisualPair}. The \texttt{magnif} value of the visual area will be determined by the \texttt{magnif} value of the \gls{map} area, the minimal dimensions allowed for the projection area preset in \texttt{this.minStrokeW} and the dimensions of the dimensions of \texttt{previewCanvas}.

Since the model of \gls{fpc} are hierarchical, we can easily see that the new \texttt{magnif} value of the next \gls{map} area will be the value of the \texttt{magnif} value of the previous visual area. After the pairing of these two \glspl{map} and forming a first \texttt{MapVisualPair}, we can repeat this process described in above paragraph until the projection area on the current \gls{map} area is big enough then set in \texttt{this.minStrokeW}. When this happens, we bind the most recent \gls{map} canvas with the main visual area canvas and form the final \texttt{MapVisualPair}. This pair is named \texttt{this.pairMain} in this manager.

And the end of the initialization process, we put all these generated \texttt{MapVisualPair}s in an array called \texttt{this.pairs} and also bind \texttt{visualContainer} which holds \texttt{visCanvas} and \texttt{previewCanvas} with this manager. Later this container will be used for the events binding of \gls{ui} interactions.

\textbf{Function} \verb|initPairMainDrag()|

This function is called after the process in \texttt{initMaps(params..)} is complete. It registers necessary event handlers for mouse dragging related events that allows for browsing around the center of the focus view like Google Maps, including:

\begin{itemize}
  \item \path{pairMainMouseDown(e)} is bound with what was set in \texttt{visContainer} property, responding to single mouse pressing event without releasing the button.
  \item \path{pairMainMouseMove(e)} is bound with what was set in \texttt{visContainer} property, responding to single mouse moving event without releasing the button.
  \item \path{pairMainMouseUp(e)} is bound with what was set in properties \texttt{visContainer} \textbf{or} anywhere on the web page, responding to single mouse button releasing event.
\end{itemize}

All the handlers are bound under the context of the current class, a.k.a \texttt{this} or \texttt{MinimapManager}.

\textbf{Function} \verb|initPairMainWheel()|

This function can be called after the process in \texttt{initMaps(params..)} is complete. In the project it is called after \texttt{initPairMainDrag()}. It registers necessary event handlers for mouse wheeling related events that allows zooming into the dataset on the fly like Google Maps. It binds the event handler \texttt{pairMainWheel(e)} to the mouse wheel event with the root document of the web page, which means when user tries to scroll the middle button of thier mouse, this handler will be triggered.

This handler is also bound under the context of the current class, a.k.a \texttt{this} or \texttt{MinimapManager}.

\textbf{Handlers and Functions Related with Mouse Dragging}

\textbf{Function} \path{pairMainMouseDown(e)}

As mentioned before, this function handles the event when user presses the left mouse button before releasing it.

When this event happens on the target, we first records the current position of the user's cursor on the attributes \texttt{dragStartX}, \texttt{dragStartY}, \texttt{dragCurrentMouseX} and \texttt{dragCurrentMouseY}, and use \texttt{window.requestAnimationFrame(callback)} to activate an animation with max frame rates allowed. The \texttt{callback} parameter in \path{window.requestAnimationFrame(callback)} is the method \texttt{pairMainStepDrag(timestamp)} of this manager and will be called every time when a new frame should be rendered to the screen and we use this mechanism to repaint the dragged image of the current focus area in the correct place.

This function also sets a \texttt{dragGlobalID} property to the class to mark that this process has been marked started.

\textbf{Function} \path{pairMainMouseMove(e)}

This function handles the situation when the user, while not releasing the left mouse button, moves the mouse around.

This function does one simple thing: if the \texttt{dragGlobalID} attribute is set on the class meaning the process of mouse dragging being started, set the current postion of user's cursor to the attributes \texttt{dragCurrentMouseX} and \texttt{dragCurrentMouseY} to be used by \texttt{pairMainStepDrag(timestamp)}.

\textbf{Function} \path{pairMainStepDrag(timestamp)}

During the phase of dragging, since this function is triggered every time a new frame is needed to be rendered, we simply grab the values in \texttt{dragCurrentMouseX} and \texttt{dragCurrentMouseY}, and compare them with \texttt{dragStartX} and \texttt{dragStartY}, and see how much the user has moved their mouse since the last frame rendered.

We then paint the image based on the offsets we calculated from these two pairs of values on the correct position.

\textbf{Function} \path{pairMainMouseUp(e)}

When user releases the mouse button after the series of the previous events, this handler gets triggered.

We repaint the image of the focus area one last time on the correct place, and put this final offset on the properties \texttt{visImgOffsetX} and \texttt{visImgOffsetY} of \texttt{this.pairMain}, and stop the animation using \texttt{window.cancelAnimationFrame(this.dragGlobalID)} with the help of the recorded \texttt{dragGlobalID}.

At this point, new coordinates of the current center of visual view will be calculated and check how many of the \texttt{MapVisualPair}s need updates. All of those that need updates will be instructed to send requests to back end resolver and fetch new image data.

The properties \texttt{visImgOffsetX} and \texttt{visImgOffsetY} are set on \texttt{this.pairMain} so next time when user starts to drag the mouse, the image of the visual area will start from the current offset and not jump back to the initial offset of this drag which is \texttt{(0, 0)}, even if the calculation from the resolver hasn't completed yet. This mechanism can be compared with this situation of Google Maps: when user is looking at location $A$ and the loading is completed, and drags the map around and stops at another location $B$, the map will start to fetch the data around location $B$. However, if the user refuses to wait and starts to drag again to a new location $C$, the second drag starts from location $B$ and not location $A$.

\textbf{Handlers and Functions Related with Zooming In and Out}

\textbf{Function} \path{pairMainWheel(e)}

This function handles the event when user scrolls the middle button of their mouse.

In this handler, we first check if this process is already ongoing or not.

If this process hasn't been started yet, we set a property \texttt{wheelCurrentRatio} representing how much user has zoomed in to \texttt{1}, and records the current \texttt{magnif} value of the visual area, \texttt{visMagnif}. We then request a same rendering mechanism trigger by \texttt{window.requestAnimationFrame} and pass on the frame executor \path{pairMainStepWheel (timestamp)} to start an animation for zooming in. After that, while the zooming animation of the current visual area image is ongoing, we set a timer of $500$ milliseconds that detects if the scrolling on the mouse button is still happening. When the timer hits, meaning within $500$ milliseconds the user hasn't scrolled the mouse button, we should consider that user wants to stop the zooming at current depth.

If this process is started already, meaning this process is still ongoing, we only refresh the counter of the timer, and reset it back to $500$ milliseconds and let the \texttt{pairMainStepWheel(timestamp)} to keep working on each frames of the animation.

\textbf{Function} \path{pairMainStepWheel()}

During the phase of zooming in or out of the dataset, this function is triggered every time a new frame is needed to be rendered. We check if the zooming direction is in or out, then repaint the zoomed image and calculate the new \texttt{visMagnif}\footnote{ As mentioned before, the \texttt{magnif} value of the main visual area.}.

\textbf{Function} \path{pairMainTimeoutWheel()}

If this function gets triggered, it means the timer has timed out and user wants to stop at current depth. Since each frame we have the value of \texttt{visMagnif} calculated, we now have a new \texttt{magnif} value for the visual area in the system. 

To make the current system has the clear resolution again, two situation can happen: user has either zoomed deeper into the dataset, or has zoomed out shallower.

When the first situation is the case, we start from the most zoomed in \gls{map}, and check whether with its \texttt{magnif} value new \glspl{map} are needed. This process is the same as described in \texttt{initMaps(params...)} since we're here also initializing new \glspl{map}, adding more to the pile of \texttt{this.pairs}.

When the second situation is the case, we do the reverse way of the initializing process. If the current projection area is larger than the most zoomed in \gls{map} entirely, this \gls{map} is no longer needed and needs to be removed. We delete this \gls{map}, invoking all the \texttt{destroy()} methods on \texttt{MapVisualPair} and their \texttt{MandelWorker}s, and move one level upper. We stop at the level where the projection area is small enough within one \gls{map}, and reconnect the current most zoomed in map with the canvas of the main visual area.

After the increment or decrement of the \glspl{map}, \texttt{MapVisualPair} that needs to get updates will be instructed to send requests to resolvers.

\subsubsection{Class \texttt{EffectManager}}\label{chap4:effectmanager}

This class manages the behaviours, activation and deactivation of the overview effects and the preview effects of the overviews.

\textbf{General Functions}

\textbf{Function} \path{init()}

This function handles the initialization of the \texttt{EffectManager}. It does the following things in an order:

\begin{itemize}
  \item Set a flag of \texttt{this.controlsInit} to \texttt{true} so this \texttt{EffectManager} won't get initialized twice.
  \item Apply the \emph{tooltip} effects of \emph{Bootstrap} on all the elements that should have tooltips.
  \item Initialize all functionalities of the controls on the general page of control panel, binding event handlers so the buttons / text fields can respond to user inputs.
  \item Initialize all controls on the page effects, algorithms and info.
  \item Bind key press event of \texttt{a}, \texttt{d}, \texttt{left arrow} and \texttt{right arrow} keys to trigger the mouse hovering event on context views.
\end{itemize}

To be more specific, during the initialization phase of general page, when user changes the value of the text field \emph{Control Panel Width}, the event handler simply applies a css \texttt{width} attribute with the designated value. When user changes the value of the dimensions of the overview or the visual area, the event handler simply sets the global variables to corresponding values and reinitialize all the managers and \texttt{MapVisualPair}s.

During the initialization phase of effects page, the function remembers the text of when no effects are activated and then apply corresponding actions when a certain item in the dropdown menus are clicked. The activation of each effect destroys all other effects and activate only that specific effect, while the \emph{Clear Effects} button simply destroys all the effects. The initialization and destruction are implemented in other functions of this manager class. For instance the process is as follows:

The essential code for the activation of the \emph{Scrollbar + Dock} effect:

\begin{verbatim}
  // The button for Scrollbar + Dock activation
  $(`#scrollbarActivator').click((e) => {
    $(`#effectsDropdownBtn').html($(`#scrollbarActivator').html());

    // this.destroyScrollbar();
    this.destroyStacked();
    this.destroyTabs();

    this.initScrollbar();
  });
\end{verbatim}

The essential code for the activation of the \emph{Stacked Cards} effect:

\begin{verbatim}
  // The button for Stacked Cards activation
  $(`#stackedActivator').click((e) => {
      $(`#effectsDropdownBtn').html($(`#stackedActivator').html());

      this.destroyScrollbar();
      // this.destroyStacked();
      this.destroyTabs();

      this.initStacked();
  });
\end{verbatim}

The essential code for the activation of the \emph{Tabs} effect:

\begin{verbatim}
  // The button for Tabs activation
  $(`#tabsActivator').click((e) => {
      $(`#effectsDropdownBtn').html($(`#tabsActivator').html());

      this.destroyScrollbar();
      this.destroyStacked();
      // this.destroyTabs();

      this.initTabs();
  });
\end{verbatim}

The essential code for the destruction of all the effect:

\begin{verbatim}
  // The button for clear of effects
  $(`#clearEffectsActivator').click((e) => {
      $(`#effectsDropdownBtn').html(this.noEffectsText);

      this.destroyScrollbar();
      this.destroyStacked();
      this.destroyTabs();
  });
\end{verbatim}

Fairly straightforward pattern of the chains of invocation.

The buttons for preview effects follow the same pattern, however, instead of invoking other functions in this manager class, they simply rebind all event handlers of mouse hovering event of context focus to new event handlers, respectively the \emph{Fade In / Out} button binds the fade related event handlers and the \emph{Zooming Through} button binds the zooming related handlers.

\textbf{Function} \path{getInfo(el)}

This function puts interested information of the running project in the element given by the parameter \texttt{el}. This function is invoked by the event handler of the \emph{Refresh} button on the \emph{Info} page of the control panel.

\textbf{General Overview Effects Functions}

The following functions are really simple, only working as a bridge between this manager and outside world invoker, including the \textbf{function} \texttt{destroy()} and \textbf{function} \texttt{update()}.

Function \texttt{update()} should be invoked when the number of the overviews are having changes, such as increament on the amount of views or decrement on them. When \texttt{MinimapManager} are making changes to the number of overviews, calling this function can ensure that newly added overviews will be arranged properly according to current selected arrangement mode. 

When \texttt{MinimapManager} are reducing the number of views presented, calling the function \texttt{destroy()} can ensure that no unnecessary memory leak will take place.

\textbf{Scrollbar + Dock Effects Specific Functions}

Function \texttt{initScrollbar()} handles the initialization process of the effect, function \texttt{destroyScrollbar()} handles the destruction and function \texttt{updateScrollbar()} handles the update event of the effect.

For this effect, two major parts are invovled. One is the scrollbar part and the other is the Apple Dock part.

The Apple Dock effects are realized through pure \gls{css} of \texttt{./css/dock.css} and will be described in \gmref{chap4:scrollbar}. During the process of \texttt{initScroll bar()}, for the purpose of applying Apple Dock effect only, only a \texttt{osx-dock} class will be applied to the containers of the overviews. During the destruction of this effect, the class \texttt{osx-dock} will be removed from the container, \texttt{\$(`\#maps-container')}.

For the scrollbar effect, an instance of \emph{MiniBar} will be created on the same container. The stylings of the scrollbar is applied through pure \gls{css} as well in \texttt{./css/minibar.cs s}. An event handler that handles the changes in the element inside the container is also attached. That handler will scroll the container to the most bottom so the newly created overview will always be on the screen. During the destruction of the effect, the \texttt{destroy()} function of the \emph{MiniBar} instance will be invoked and reference will be removed to avoid memory leak.

\textbf{Stacked Cards Effects Specific Functions}

Function \texttt{initStacked()} handles the initialization process of the effect, function \texttt{destroyStacked()} handles the destruction and function \texttt{updateStacked()} handles the update event of the effect.

For this effect, the process of initialization and update is almost the same. In fact, at the end of the initialization process, function \texttt{initStacked} invokes \texttt{updateStacked}.

For the update process of this effect, first a delicate calculation is performed to determine whether the current screen can hold one column of overviews. If it can hold all the overviews inside one screen, no further actions will be performed. If not, a \texttt{stacked} class will be added to the \texttt{\$(`\#maps-container')} as well as 3d transformation \gls{css} attributes also being added to every single one of the overviews present. A tooltip will also be added to all the overviews popping out on the right side of each overview indicating the magnification level of each overview.

For the destruction phase of this effect, all the process did in the update phase will be reversed and then arrangement of the overviews will return to its original state.

It is also worth mentioning that the arrangement with equal margins and space between the overviews vertically, the \gls{css3} technique of flexbox\footnote{ For more information about flexbox in \gls{css3}, see \url{https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox}.} is used.

\textbf{Tabs Effects Specific Functions}

Function \texttt{initTabs()} handles the initialization process of the effect, function \texttt{destroy Tabs()} handles the destruction and function \texttt{updateTabs()} handles the update event of the effect.

This effect is very similar to the \emph{Stacked Cards} effect, except for that it calculates the width of the container instead of height and applies horizontal distribution and sizes for all the overviews. A whole new different set of calcuation is performed since the control panel also occupies a portion of screen, however, the actions to be taken in \gls{js} file is in a similar structure with the ones in the \emph{Stacked Cards} effect.

\textbf{General Preview Effects Functions}

Following the patterns of \texttt{EffectManager}, several generic functions are included for the controls of the preview effects.

Functions \texttt{updatePreview()} should be invoked when changes of numbers of overvie-ws are taken place. It will invoke corresponding secondary functions whether \texttt{update FadePreview()} or \texttt{updateZoomPreview()}, according to the current activated preview effects.

Function \texttt{destroyPreview()} handles the the destruction of the preview effects. After invocation no preview effects will be animated.

As for the updates of preview effects, for example \texttt{updateFadePreview()}, the mechanism is simply attach event handlers to all overviews currently present. The attached event handlers are corresponding event handlers for specific effects, for example \texttt{updateFade Preview()} will attach the event handler \path{fadeMouseOver(e, currentPa ir)} and \path{fadeMouseOut(e, currentPair)} to corresponding events.

\textbf{Fade In / Out Event Handlers}

The \emph{Fade In / Out} preview effect specific functions include two functions, the one handles the mouse over event \texttt{fadeMouseOver(e, currentPair)} and the one that handles the mouse leaving focus area event \texttt{fadeMouseOut(e, currentPair)}.

When function \texttt{fadeMouseOver(e, currentPair)} is invoked with the event parameter \texttt{e}, it means the user tries to activate the preview of one context view. What this function does is to first check whether the preview canvas is visible or not. If it is visible, indicating that user was previewing another overview, it will stop the current animation of the preview canvas and then makes it fade in with correct image data after a small fading out animation of the previous image data. This function is like an ``entry'' of an overview.

It the preview canvas is not visible at the beginning of the invocation of this function, then it simply just render correct image data on the preview canvas and makes it fade in so the user can see the image data.

When function \texttt{fadeMouseOut(e, currentPair)} is invoked, it will simply fade out the preview canvas. It is like an ``exit'' of an overview.

Note that all fading effects are performed on the transparancy of the mentioned elements.

\textbf{Zooming Through Event Handlers}

The \emph{Zooming Through} preview effect specific functions include three functions, other than the one handles the mouse over event \texttt{zoomMouse Over(e, currentPair)} and another one that handles the mouse leaving focus area event \texttt{zoomMouseOut(e, curr entPair)}, there is a third function \texttt{zoomStep(timestamp)}.

First of all, the mechanism of the \emph{Zooming Through} preview effect is different from the preview effect \emph{Fade In / Out}.

When the mouse over event gets triggered, meaning one overview with a certain index is requested. This index will be called destination depth. The function \texttt{zoomMouse Over(e, currentPair)} records that index, and kickstart the function \texttt{zoomStep(time stamp)} if it's not already started. The kickstarting mechanism is again the described \texttt{window.cancelAnimationFrame} mechanism that ensures high \gls{fps} performance.

When the mouse leaving event(\texttt{zoomMouseOut(e, currentPair)}) gets triggered, the function will simply change the destination depth to a number that's $1$ larger than the amount of overviews present, indicating the destination depths is leaving the overviews, a.k.a destination depth being details view depth.

The function \texttt{zoomStep(timestamp)} handles ``one step'' of the zooming process. If it gets triggered, it'll first check if the desired destination depth is reached or not. If it is reached, it stops the zooming animation with destination image data. If not, it enlarges the image data from current depth of the \gls{fpc} pair or shrinks it towards target depth until it reaches the destination.

From the described content in this part, we can see that unlike the \emph{Fade In / Out} mechanism, the mouse over events and mouse out events are not like entries and exits of an overview, but navigation beacons. The mouse over event is to guide the preview canvas to stop at a certain depth of overviews, while the mouse out event is to guide it to stop at maximum depth of the entire system of the \gls{fpc}s.

\subsubsection{Instantiation, Variables and the Rest}

After defining several key classes, several ``global''\footnote{ Technically not the global scope of entire \texttt{index.js} file per se, but the ``global scope'' of entire anonymous function that envelops all the codes.} variables are defined.

Most of the defined variables are referenced, used and modified across the life cycle of the project. They include the following:

\begin{itemize}
  \item \texttt{screenWidth} The screen width of the user screen monitor in pixels, pre-defined as a fixed value, should be changed when user puts a new value in the control panel.
  \item \texttt{screenHeight} The screen height of the user screen monitor in pixels, similar to \texttt{screenWidth}.
  \item \texttt{mapWidth} The width of the overviews in pixels, pre-defined and used across the project to generate new overviews.
  \item \texttt{mapHeight} The height of the overviews in pixels, similar to \texttt{mapWidth}.
  \item \texttt{controlPanelWidth} The width of the control panel in pixels, should be changed when user inputs a new value in \emph{General} tab in control panel.
  \item \texttt{visMagnif} The starting magnification level of the visual area.
  \item \texttt{mapMagnif} The magnification of the first overview view.
  \item \texttt{hoverX} The x component of the starting center point that the user looks at in the dataset.
  \item \texttt{hoverY} The y component of the starting center point.
  \item \texttt{mainCanvas} A canvas that's dynamically created during the instantiation phase of the project and saved in this variable as a reference. It will be appended to the container \texttt{\$(`\#visual-container')}.
  \item \texttt{previewCanvas} A canvas that's dynamically created after the creation of \texttt{main Canvas}, during the instantiation phase of the project, saved in this variable as a reference and overlays on the \texttt{mainCanvas}. It will be appended to the container \texttt{\$(`\#visual-container')} too.
  \item \texttt{\$(`\#visual-container')} The container that contains \texttt{mainCanvas} and \texttt{preview Canvas}. For the \gls{dom} structure, see \gmref{fig:rootdom}.
  \item \texttt{\$(`\#maps-container')} The container that contains all the context views. For the \gls{dom} structure, see \gmref{fig:rootdom}.
\end{itemize}

After the definition of variables and the creation of dynamic canvases, class \texttt{Minimap Manager} and class \texttt{EffectManager} are instantiated with the defined variables, created canvases and corresponding containers described above. The project should be running smoothly from this point on.

\subsection{CSSs for Overview Effects}
\label{chap4:frontend-css}

Folder \texttt{./css} includes five \gls{css} files, each setting up some visual effects of the project.

File \texttt{./css/common.css} first sets up all general appearance of the elements on the web page when no parameters or effects are set. File \texttt{./css/dock.css} sets up the appearance when \emph{Scrollbar + Dock} is activated, only the iOS Dock part and file \\\texttt{./css/minibar.css} sets up the scroll bar part. File \texttt{./css/stacked.css} sets up the effects of stacked cards. File \texttt{./css/tabs.css} sets up the effects of the tab selection on the top.

\subsection{Scrollbar + Dock Effect}
\label{chap4:scrollbar}

The realization of the effect consists of two parts, \gls{js} and \gls{css} part.

The \gls{js} part is as mentioned before, include \texttt{initScrollbar()}, \texttt{destroyScrollbar()} and \texttt{updateScrollbar()} in class \texttt{EffectManager}.

After the corresponding \gls{js} part finish its actions, \gls{css} codes will be put to actions once the \texttt{class} attribute is added to the container.

In the file \texttt{./css/minibar.css}, styles are applied to \texttt{.mb-container} which is a class applied from within the dependency \emph{MiniBar} and to \texttt{.mb-bar} which is the bar itself. Styles add nice and modern looking coloring to the background of the slider, as well as a comfortable color on the bar --- all of them with good transparancy.

\begin{figure}[H]
\centering
\includegraphics[width=.45\textwidth,keepaspectratio]{Figures/Chapter4/minibar.png}
\decoRule
\caption[Styles of Scrollbar]{An illustration of the appearance of the scrollbar.}
\label{fig:minibar}
\end{figure}

The file \texttt{./css/dock.css} applies styles on the container \texttt{.osx-dock} which is a class that will only be added when Apple Dock effect are to be put on a certain container. It first specifies that all the transitions of the children nodes should be performed smoothly with a linear function, and specifically the effect of the halo effect should be animated a little bit slower. A simple demonstration is as follows:

\begin{verbatim}
  /* Webkit vendor properties before native properties */
  -webkit-transition: all .15s linear, box-shadow .85s ease-out;

  /* Native property of transition, all transitions in */
  /* 0.15 seconds, halo effects, however within longer */
  /* period of time, in 0.85 seconds                   */
  transition: all .15s linear, box-shadow .85s ease-out;
\end{verbatim}

And then all the \texttt{<canvas>} elements in the container \texttt{.osx-dock} should be initially scaled down by 15\%, achieved through:

\begin{verbatim}
  -webkit-transform: scale(0.85);
  transform: scale(0.85);
\end{verbatim}

Once an overview is focused, it should be enlarged the most with the largest margin between its adjacent siblings. The \gls{css} selector is \texttt{\#maps-container.osx-dock .li:hover} for the element itself and the \texttt{<canvas>} element \texttt{\#maps-container.osx-do ck .li:hover canvas}. The overview element should be put on top of everything so it will not be overlaid and put with correct margins. The \texttt{<canvas>} element will be put with a scale of $1.1$.

The styles of adjacent overviews are applied to \gls{css} selector \texttt{\#maps-container.osx-d ock .li.nearby} and \texttt{\#maps-container.osx-dock .li.nearby canvas}. Margins for the \texttt{.li.nearby} element are smaller than they are for the focused overview and the scale of the \texttt{<canvas>} element is $0.93$, like it is for the Apple Dock effect --- adjacent items are enlarged but not as large as the focus item.

\subsection{Stacked Cards Effect}
\label{chap4:cards}

The realization of the effect consists of also two parts, \gls{js} and \gls{css} part.

The \gls{js} part is as mentioned before, include \texttt{initStacked()}, \texttt{destroyStacked()} and \texttt{updateStacked()} in class \texttt{EffectManager}.

After the corresponding \gls{js} part applies necessary \gls{css} class selectors, styles for \emph{Stacked Cards} effects will automatically be activated.

First of all, the file \texttt{./css/stacked.css} applies flexbox properties\footnote{ For more information about flexbox in \gls{css3}, see \url{https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox}.} on the container \texttt{\#maps-container.stacked} and its children \texttt{\#maps-container.stacked .li}, making all overviews occupying an equal amount of space on the y-axis of the screen, and when space is not enough to hold them all, stretch all the overviews.

On the container, the core of the flexbox properties are applied:

\begin{verbatim}
  #maps-container.stacked {
    display: flex;
    flex-direction: column;
    align-items: stretch;
  }
\end{verbatim}

On the children of the container, the core of the flexbox properties are applied:

\begin{verbatim}
  #maps-container.stacked .li {
    flex: 1;
    min-height: 0;
  }
\end{verbatim}

Note that the \texttt{min-height} property make the children, here the overview elements, able to be stretched when needed.

After the space distribution, 3d effect properties are also set for each overview elements. The virtual distance between the camera and the web page is set to be $200$ pixels and centered on the left border of the screen, by:

\begin{verbatim}
  #maps-container.stacked .li {
    perspective: 200px;
    perspective-origin: left;
  }
\end{verbatim}

The angle of the rotations on the x-axis of the screen of each individual overviews are set through \gls{js} and can have nice visual effects in combination with the example code.

The focus element should return to the state of not rotated on the x-axis, by:

\begin{verbatim}
  #maps-container.stacked .li:hover canvas {
    transform: rotateX(0deg);
  }
\end{verbatim}

\subsection{Tabs Effect}
\label{chap4:tabs}

The realization of the effect is architecturally similar with the previous two effects.

After classes are added and \gls{css} selectors have taken effect, the following styles within \texttt{./css/tabs.css} are applied to container and its children:

\begin{verbatim}
  #maps-container.tabs {
    display: flex;
    flex-direction: row;
    align-items: stretch;
  }

  #maps-container.tabs .li {
    flex: 1;
    min-width: 0;

    overflow: hidden;
  }
\end{verbatim}

Note that only essential positioning \gls{css} codes are described here.

The \gls{css} attribute \texttt{min-width} is worth mentioning here that instead of \texttt{min-height} in the effect \emph{Stacked Cards}, widths of the overviews will be adjusted in this effect and the \texttt{flex-direction} becomes \texttt{row} instead of \texttt{column}, different from the previous effect.

The focus mechanism, however, has a slightly different implementation. The focus overview should be expanded into its full form and will not keep getting shrunk, by the \gls{css} attribute \texttt{min-width} being set to the value of the variable \texttt{mapWidth} by \gls{js} dynamically.

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Back End Calculation}

The back end calculation is done in the \gls{js} file \texttt{naive-worker.js}. This file is being used for initializing the \emph{Web Worker}s inside \texttt{index.js} dynamically. Whenever a calculation or extraction for a specific region of a dataset is needed, the main \gls{js} file \texttt{index.js} is going to send a message to \texttt{naive-worker.js} with desired parameters and this back end will respond with corresponding image data.

\begin{figure}[th]
\centering
\includegraphics[width=.85\textwidth,keepaspectratio]{Figures/Chapter4/messageexchange.png}
\decoRule
\caption[Message Exchange]{Message exchange between \texttt{index.js} and \texttt{naive-worker.js}.}
\label{fig:messageexchange}
\end{figure}

\subsection{Global Scope}

In the global scope of this file, the following things were done.

\paragraph{Includes} The \texttt{decimal.js} dependency is included for high-precision floating points calculation. Default parameters for the dependency is set.

\paragraph{Constants} Constants of default screen width and default screen height are defined in case the front end doesn't give these parameters.

\paragraph{Canvas} An \texttt{OffscreenCanvas} instance is created and instantiated with the dimensions of by default the values of the defined constants. The \texttt{OffscreenCanvas} will be used as the canvas to generate the desired image on, and since it's not being shown on the screen, will occupy less system resources and boost the calculation speed. Corresponding variables is declared after the instantiation, respectively \texttt{canvas} for the \texttt{OffscreenCanvas} itself and \texttt{ctx} as the 2d context of the canvas.

\subsection{Message Reception}

As shown \gmref{fig:messageexchange}, when the file \texttt{index.js} sends a request of \texttt{work(params..)} to this file, the function, message reception function, defined as \texttt{onmessage = function (e) \{ ... \}}, will be invoked.

The process is as follows:

\begin{enumerate}
  \item Mark the current timestamp by \texttt{let ts = performance.now();}.
  \item Check the magnification level requested.
  \item Use the correct version of the calculation method, whether the normal version of the function \texttt{getMandelCounts(params..)} or the high precision version \texttt{getMandelCountsHighPrecision(params..)}. Note that the parameters for these two functions are exactly the same.
  \item Mark the new timestamp after the calculation completes and calcuate the time used for the calcuation.
  \item Post the message back to front end by \texttt{postMessage(workerResult);}.
  \item Destroy used resources and allow for garbage collection to avoid memory leak.
\end{enumerate}

After the process is done, the \emph{Web Worker} will be idle and wait for next requests.

Note that the function starting with the name \texttt{getMandelCounts} should return a result containing the calcuated image data, as well as the input parameters came from the front end that can be used to verify at the front end.

\subsection{Iteration Limit}

The function \texttt{getIterationLimit(magnif)} calcuates the $max$ value in \gmref{alg:simple} and \gmref{alg:grayscale}. It is a \gls{js} represented way of \gmref{eq:max}. The essential code is as follows:

\begin{verbatim}
  Math.pow(50 * (Math.log10(magnif)), 1.08);
\end{verbatim}

\subsection{Iteration Count for One Point}

To get the iteration count for one point on the mathmatical complex plane, function \path{calcIterationCount(x, y, maxIterations = 1000)} is used.

The parameters \texttt{x} and \texttt{y} represents the x and y coordinates on the complex plane to be calcuated, and the parameter \texttt{maxIterations} can be omitted and if so, this function will use $1000$ as the max iteration limit. However, this parameter is always passed on to this function since from where this function gets invoked, in the image generation funciton \texttt{getMandelCounts(params..)} and \texttt{getMandelCountsHighPrecision(param s..)}, it passes the result that comes from the function \texttt{getIterationLimit(magnif)} that gives a proper iteration limit.

This function implements the inner loop of the algorithms described in \gmref{alg:simple} and \gmref{alg:grayscale}.

It it worth mentioning that a small enhancement on the performance is used inside this function. Since every time squares of the real component and imaginary component are always needed in the next iteration, the following code is used to reduce the number of multiplications down to $3$ times every iteration:

\begin{verbatim}
  for (let i = 0; i < maxIterations; i++) {            
    im = im * re; // First multiplication
    im = im + im + y;

    re = re2 - im2 + x;

    re2 = re * re; // Second multiplication
    im2 = im * im; // Third multiplication

    // Use addition instead of square root,
    // Use 4 instead of 2, since 4 = 2^2
    if (re2 + im2 > 4) {
      return i;
    }
  }
\end{verbatim}

\subsection{Image Generation}

As described above, the function \path{getMandelCounts(magnif, centerX, centerY, width, height, max = null)} is used for image generation and results responding.

The parameters of this function is pretty self-explanatory:

\begin{itemize}
  \item \texttt{magnif} is the magnification level of the result image data that the front end is requesting.
  \item \texttt{centerX} and \texttt{centerY} are the coordinates of the center of the image data that the front end is requesting.
  \item \texttt{width} and \texttt{height} are the dimensions of the result image data in pixels.
  \item \texttt{max} can be omitted and if so, this function will use the results from the function \texttt{getIterationLimit(magnif)} that gives a proper iteration limit with the help of the passed parameter \texttt{magnif}.
\end{itemize}

The process of this calculation is optimized on a certain scale, following the algorithms described in \gmref{alg:grayscale}, as follows:

\begin{enumerate}
  \item Initialize a blank image data object, dimensions of how large one single pixel is on the complex plane, the width and height on the complex plane of the to be generated image data, and the current timestamp before starting the calcuation.
  \item Set up the coordinates of the top left corner of the image data on the complex plane.
  \item Start the iteration through all the pixels to be generated and fill the 2-dimensional image data array.
  \item If the time used for calculation has passed $500$ milliseconds and at least one slice of image data is finished with its calcuation, use \texttt{postMessage(params..)} to return a partial result to the front end.
  \item At the end of the function after the color of all the pixels are calculated, return the result image data together with parameters.
\end{enumerate}

During this process, the structure of the returning results need to be described here.

The structure of the partial result is in \gls{json} format of \gls{js}, as follows:

\begin{verbatim}
  postMessage({
    final: false, result it not final,
    img: calculated image data,
    min: current minimum iteration counts,
    max: current maximum iteration counts,
    magnif: passed value of magnif to be verified,
    centerX: passed centerX value,
    centerY: passed centerY value,
    width: passed width value,
    height: passed height value,
    partStartY: the y coordinates in pixels that
      current slices of image data starts from,
    partHeight: the total height for this packet
      of image data,
  });
\end{verbatim}

The structure of the final result is also in \gls{json} format as follows:

\begin{verbatim}
  return {
    final: true,
    img: calculated image data,
    min: current minimum iteration counts,
    max: current maximum iteration counts,
    magnif: passed value of magnif to be verified,
    centerX: passed centerX value,
    centerY: passed centerY value,
    width: passed width value,
    height: passed height value,
  }
\end{verbatim}

We can notice that the value of \texttt{final} attribute is set to \texttt{true} and the attributes \texttt{partStartY} and \texttt{partHeight} is left out.

\subsection{High Precision Version}

Function \texttt{calcIterationCount(params..)} and function \texttt{getMandelCounts(params..)} have both a high precision version of them. They are used when the magnification level are to high for native \gls{js} float numbers to handle.

The high precision version of the two functions are named respectively \texttt{calcIteration CountHighPrecision(params..)} and function \texttt{getMandelCountsHighPrecision\\(params..)} --- only adding a \texttt{HighPrecision} at the end of the names of the functions, with exactly the same signature of the parameters.

%----------------------------------------------------------------------------------------
%	SECTION 
%----------------------------------------------------------------------------------------

\section{Utility Assets}

Other open source third-party utilities lie in different folders with corresponding names.

\subsection{Folder \texttt{./js}}

In \texttt{./js} folder, all \gls{js} third-party files are here, including:

\begin{itemize}
    \item File \texttt{decimal.min.js} is for high-precision floating points calculation for \gls{js}.
    \item File \texttt{jquery-3.4.1.min.js} is for \gls{dom} traversal and manipulation, event handling and animation.
    \item File \texttt{bootstrap.bundle.min.js} is for some basic styling of the control panel sitting on top right corner of the screen.
\end{itemize}

\subsection{Folder \texttt{./fa}}

In the folder \texttt{./fa} there is all the necessary file needed for the dependency \emph{FontAwesome}, the web's most popular icon set and toolkit.

In the current project, we're only using the free and open-source part of this dependency and the used icons shown in \gmref{fig:fa}.

\begin{figure}[H]
\centering
\includegraphics[width=.5\textwidth,keepaspectratio]{Figures/Chapter4/fa.png}
\decoRule
\caption[FontAwesome Icons]{Used \emph{FontAwesome} icons in the project.}
\label{fig:fa}
\end{figure}

\subsection{Folder \texttt{./bs}}

In the folder \texttt{./fa} there is all the necessary file needed for the dependency \emph{Bootstrap} as mentioned multiple times in this project.

\emph{Bootstrap} is an open source toolkit for developing with \gls{html}, \gls{css}, and \gls{css}. It allows ideas and building applications with Sass\footnote{ To know more about Sass, see \url{https://sass-lang.com/}.} variables and mixins, responsive grid system, extensive prebuilt components, and powerful plugins built on jQuery.

In this project, however, we're using only a small part of \emph{Bootstrap}, to be more specific, the appearance of the control panel, including:

\begin{itemize}
  \item Form elements, such as input text fields and checkboxes
  \item Tab pages, for example the four categories of the control panel with corresponding tab pages
  \item Dropdown menus, for example the two dropdown selections in \emph{Effects} tab page
  \item Appearances of buttons and colored themes, such as green buttons and red dropdown buttons
\end{itemize}